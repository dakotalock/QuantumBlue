# -*- coding: utf-8 -*-
"""Untitled13.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1r5zQeh3g9jzosLx5WkC1ms29TuyBtA4A
"""


import dill

import chess

import numpy as np

import random

from qiskit.circuit.library import EfficientSU2

from qiskit.algorithms.optimizers import COBYLA

from qiskit_machine_learning.algorithms import VQC

from qiskit_machine_learning.neural_networks import TwoLayerQNN

from qiskit import Aer

from qiskit.utils import QuantumInstance

from qiskit.circuit import ParameterVector

backend = Aer.get_backend('qasm_simulator')

quantum_instance = QuantumInstance(backend, shots=1024, seed_simulator=42, seed_transpiler=42)



# Classical evaluation based on material values

def classical_evaluation(board):

    piece_values = {

        chess.PAWN: 1,

        chess.KNIGHT: 3,

        chess.BISHOP: 3,

        chess.ROOK: 5,

        chess.QUEEN: 9,

        chess.KING: 0

    }



    score = 0

    for piece_type in piece_values.keys():

        for piece in board.pieces(piece_type, chess.WHITE):

            score += piece_values[piece_type]

        for piece in board.pieces(piece_type, chess.BLACK):

            score -= piece_values[piece_type]



    return score



# Generate a random chess game

def generate_random_chess_game(num_moves):

    game_moves = []

    board = chess.Board()



    for _ in range(num_moves):

        if board.legal_moves:

            move = random.choice(list(board.legal_moves))

            game_moves.append(move)

            board.push(move)



    return game_moves, board



# Limit the model to only legal moves

def limit_to_legal_moves(predicted_moves, board):

    legal_moves = list(board.legal_moves)

    legal_move_predictions = predicted_moves * np.array([int(move in legal_moves) for move in predicted_moves])

    move = legal_moves[np.argmax(legal_move_predictions)]

    return move



# Create a classical feature extraction function
def extract_features(board):
    features = []

    for sq in chess.SQUARES:
        piece = board.piece_at(sq)
        if piece:
            piece_type = piece.piece_type
            features.append(piece_type)
        else:
            features.append(0)

    return np.array(features)

# Define the quantum feature map and create a QuantumInstance
num_qubits = 64
quantum_feature_map = EfficientSU2(num_qubits)
quantum_ansatz = EfficientSU2(num_qubits)

def _interpret(self, b):
  """Interpret the binary string as a quantum state."""
  if isinstance(b, int):
    return b
  else:
    return 0

def _probabilities(self, input_data, weights):
  """Calculate the probabilities of the output labels."""
  probabilities = {}
  for b in range(2**len(input_data)):
    key = bin(b)[2:].zfill(len(input_data))
    callable_key = lambda: key
    probabilities[key] = self._circuit._probabilities(input_data, weights, callable_key)
  return probabilities

def get_ai_move(board):

    input_array = np.array([extract_features(board)]).reshape(1, -1)

    print("Input array shape:", input_array.shape)

    predictions = loaded_vqc.predict(input_array)

    print("Predictions:", predictions)

    move = limit_to_legal_moves([predictions], board)  # Change this line

    return move


from qiskit.circuit import Parameter, QuantumCircuit

def create_custom_circuit(num_qubits, prefix):
    custom_circuit = QuantumCircuit(num_qubits)
    for i in range(num_qubits):
        custom_circuit.ry(Parameter(f"{prefix}theta[{i}]"), i)
    return custom_circuit

# Create separate circuits for the quantum_feature_map and the quantum_ansatz
quantum_feature_map = create_custom_circuit(num_qubits, prefix='fm_')
quantum_ansatz = create_custom_circuit(num_qubits, prefix='a_')

# Change the optimizer to SPSA
from qiskit.algorithms.optimizers import SPSA
classical_optimizer = SPSA()

# Load the saved VQC model from the dill file

with open("C:\\Users\\dakot\\Downloads\\vqc_model.dill", "rb") as f:


    loaded_vqc = dill.load(f)

import traceback

import logging

import chess

import chess.svg

import traceback

from flask import Flask, Response, request

import webbrowser



app = Flask(__name__)

board = chess.Board()



@app.route("/")

def main():

    ret = '<html><head>'

    ret += '<style>input { font-size: 18px; } button { font-size: 18px; }</style>'

    ret += '</head><body>'

    ret += chess.svg.board(board=board, size=400)

    ret += '<form action="/move/" method="post"><input name="move" type="text"></input><input type="submit" value="Make Move"></form>'

    ret += '<form action="/dev/" method="post"><button name="AI Move" type="submit">Make AI Move</button></form>'

    ret += '<form action="/undo/" method="post"><button name="Undo Move" type="submit">Undo Move</button></form>'

    ret += '<form action="/new/" method="post"><button name="New Game" type="submit">New Game</button></form>'

    ret += '</body></html>'

    return ret



@app.route("/move/", methods=['POST'])

def move():

    try:

        move = request.form['move']

        board.push_san(move)

    except Exception:

        traceback.print_exc()

    return main()





@app.route("/dev/", methods=['POST'])

def dev():

    try:

        ai_move = get_ai_move(board)

        board.push(ai_move)

    except Exception:

        logging.error("Error occurred while making AI move:")

        traceback.print_exc()

    return main()


@app.route("/undo/", methods=['POST'])

def undo():

    try:

        board.pop()

    except Exception:

        traceback.print_exc()

    return main()



@app.route("/new/", methods=['POST'])

def new():

    global board

    board = chess.Board()

    return main()



if __name__ == "__main__":

    webbrowser.open("http://127.0.0.1:5001/")

    app.run(host='0.0.0.0', port=5001, debug=True)